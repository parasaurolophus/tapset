# `fileprovider` Library #

Android has always encouraged the use of a published [ContentProvider](http://developer.android.com/reference/android/content/ContentProvider.html) to share data between apps. However, the use of URI's by such providers and the limitations on the size of binary 'extras' in bundles and intents caused most developers to "cheat" when sharing large BLOB's of data for which standard file types are exist, e.g. images, audio clips, video clips etc. This works simply by making a given file readable by any app and then sharing a `file:` URI instead of a `content:` URI. While always being regarded as a bit of a hack, this technique is simple and straightforward for both the "provider" and consumer of such files since they rely mainly on pure Java file I/O API's with only a minimal amount of Android-specific "glue" holding them together.

Recently, Google upped the ante against this "hack," however, by deprecating the [MODE\_WORLD\_READABLE](file:///C:/Program%20Files%20(x86)/Android/android-sdk/docs/reference/android/content/Context.html#MODE_WORLD_READABLE) flag on which it relies. While the technique still works, you now have to live with the compiler warning or bring yourself to suppress it, with the nagging worry that "deprecated" might become "undefined" in some future version of the SDK.

The [FileProvider](https://code.google.com/p/tapset/source/browse/fileprovider/src/us/rader/provider/file/FileProvider.java) class contained in the `fileprovider` library solves this problem by wrapping the file I/O in a "proper" content provider. No `MODE_WORLD_READABLE` required, and so no compiler warning. (Ironically, there will now be a `lint` warning regarding security concerns with published content providers eerily reminiscent of the deprecation warning for `MODE_WORLD_READABLE`, but such `lint` warnings can be suppressed with far less worry than deprecation.)